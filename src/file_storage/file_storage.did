type AssetProperties = record {
  content_type : text;
  filename : text;
  checksum : nat32;
  content_encoding : ContentEncoding;
};
type AssetQuery = record {
  id : nat;
  url : text;
  owner : principal;
  canister_id : principal;
  content_size : nat32;
  content_type : text;
  created_at : nat64;
  filename : text;
  content_encoding : ContentEncoding;
  chunk_size : nat32;
};
type ContentEncoding = variant { GZIP; Identity };
type HttpRequest = record {
  url : text;
  method : text;
  body : vec nat8;
  headers : vec record { text; text };
};
type HttpResponse = record {
  body : vec nat8;
  headers : vec record { text; text };
  streaming_strategy : opt StreamingStrategy;
  status_code : nat16;
};
type Result = variant { Ok : nat; Err : text };
type Result_1 = variant { Ok : text; Err : text };
type Result_2 = variant { Ok : AssetQuery; Err : text };
type StreamingCallbackHttpResponse = record {
  token : opt StreamingCallbackToken;
  body : vec nat8;
};
type StreamingCallbackToken = record {
  chunk_index : nat32;
  asset_id : nat;
  content_encoding : text;
};
type StreamingStrategy = variant {
  Callback : record {
    token : StreamingCallbackToken;
    callback : func () -> ();
  };
};
service : {
  assets_list : () -> (vec record { nat; AssetQuery }) query;
  chunk_availabity_check : (nat32) -> (bool) query;
  commit_batch : (vec nat32, AssetProperties) -> (Result);
  create_chunk : (vec nat8, nat32) -> (nat32);
  delete_asset : (nat) -> (Result_1);
  get : (nat) -> (Result_2) query;
  http_request : (HttpRequest) -> (HttpResponse) query;
  http_request_streaming_callback : (StreamingCallbackToken) -> (
      StreamingCallbackHttpResponse,
    ) query;
  is_full : () -> (bool);
  version : () -> (nat) query;
}